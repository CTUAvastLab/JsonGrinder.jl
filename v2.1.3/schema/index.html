<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Schema · JsonGrinder.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function () {
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';
        document.getElementsByTagName('head')[0].appendChild(meta);
    };
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; width: 100%; top: 0; left: 0; box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border-bottom: 1px solid #d54625; padding: 10px 35px; text-align: center; font-size: 15px;');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: calc(50% - 8px); right: 18px; cursor: pointer; width: 12px;');
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '" style="color: rgb(46, 99, 184)">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
});
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="JsonGrinder.jl logo" class="docs-light-only" src="../assets/logo.svg"/><img alt="JsonGrinder.jl logo" class="docs-dark-only" src="../assets/logo-dark.svg"/></a><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href="">Schema</a><ul class="internal"><li><a class="tocitem" href="#Implementation-details"><span>Implementation details</span></a></li><li><a class="tocitem" href="#Extra-functions"><span>Extra functions</span></a></li></ul></li><li><a class="tocitem" href="../extractors/">Creating extractors</a></li><li><a class="tocitem" href="../exfunctions/">Extractor functions</a></li><li><a class="tocitem" href="../automl/">AutoML</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li><li><a class="tocitem" href="../developers/">Developers</a></li><li><a class="tocitem" href="../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Schema</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Schema</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pevnak/JsonGrinder.jl/blob/master/docs/src/schema.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Schema"><a class="docs-heading-anchor" href="#Schema">Schema</a><a id="Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Schema" title="Permalink"></a></h1><p>The schema helps to understand the structure of JSON files, by which we understand the types of nodes (Dict, Array, Values) and frequency of occurrences of values and lengths of arrays. The schema also holds statistics about how many times the node has been present. All this information is taken into the account by <code>suggestextractor</code> function, which takes a schema and using few reasonable heuristic, suggests an extractor, which convert jsons to Mill structure. The schema might be also useful for formats with enforced schema to collect statistics on leaves.</p><p>The main function to create schema is <code>schema</code>, which accepts a list of (unparsed) JSONs and producing schema. Schema can be always updated to reflect new JSONs and allow streaming by <code>update!</code> function. Moreover, <code>schema</code> accepts an optional argument, a function converting an element of an array to a JSON. This a function creating schema from all jsons in a dictionary can look like</p><pre><code class="language-julia">schema(readdir("jsons", join = true)) do s
	open(s,"r") do fio
		read(fio, String)
	end |&gt; JSON.parse
end</code></pre><p><code>schema</code> function has following default behavior: If passed array of strings, it consideres them to be json documents as strings passes each element as an argument to <code>JSON.parse</code> function.</p><p>A schema can be further updated by calling function <code>update!(sch, json).</code> Schemas can be merged using the overloaded <code>merge</code> function, which facilitates distributed creation of schema following map-reduce paradigm.</p><p>Schema can be saved in html by <code>generate_html</code> allowing their interactive exploration. Calling <code>generate_html(filename, sch)</code> will generate self-contained file with HTML+CSS+JS. The generated visualization is interactive, implemented using VanillaJS.</p><p>Schema assumes the root of each JSON is dictionary.</p><h2 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h2><p>Statistics are collected in a hierarchical structure reflecting the structured composed of <code>DictEntry</code>, <code>ArrayEntry</code>, and <code>Entry.</code> These structures reflect those in JSON: <code>Dict</code>, <code>Array</code>, and Value (either <code>String</code> or a <code>Number</code>). Sometimes, data are stored in JSONs not adhering to a stable schema, which happens if one key have children of different type. An example of such would be</p><pre><code class="language-json">{"a": [1,2,3]}
{"a": {"b": 1}}
{"a": "hello"}</code></pre><p>For such cases, we have introduced additional <code>JSONEntry</code>, a <code>MultiEntry,</code> but we discourage to rely on this feature and recommend to adapt JSONs to have stable schema (if possible). This can be achieved by modifying each sample before it's passed into the schema.</p><p>Each subtype of <code>JSONEntry</code> implements the <code>update!</code> function, which recursively updates the schema.</p><h3 id="Entry"><a class="docs-heading-anchor" href="#Entry">Entry</a><a id="Entry-1"></a><a class="docs-heading-anchor-permalink" href="#Entry" title="Permalink"></a></h3><pre><code class="language-julia">mutable struct Entry{T} &lt;: JSONEntry
	counts::Dict{T,Int}
	updated::Int
end</code></pre><p><code>Entry</code> keeps information about leaf-values (e.g. <code>"a" = 3</code>) (strings or numbers) in JSONs. It consists of two statistics</p><ul><li><code>updated</code> counts how many times the leaf in a given position in JSON was observed,</li><li><code>counts</code> counts how many times a particular value of that leaf was observed.</li></ul><p>To keep <code>counts</code> dictionary from becoming too large, once its length exceeds <code>JsonGrinder.max_keys</code> (default is <code>10_000</code>), then the new values will be dropped. This value can be changed by <code>JsonGrinder.updatemaxkeys!(some_higher_value)</code>, but of course the new limit will be applied only to newly processed values, so it's advised to set it in the beginning of your scripts.</p><h3 id="ArrayEntry"><a class="docs-heading-anchor" href="#ArrayEntry">ArrayEntry</a><a id="ArrayEntry-1"></a><a class="docs-heading-anchor-permalink" href="#ArrayEntry" title="Permalink"></a></h3><pre><code class="language-julia">mutable struct ArrayEntry &lt;: JSONEntry
	items
	l::Dict{Int,Int}
	updated::Int
end</code></pre><p><code>ArrayEntry</code> keeps information about arrays (e.g. <code>"a": [1,2,3,4]</code>). Statistics about individual items of the array are deferred to <code>item</code>, which can be <code>&lt;:JSONEntry</code>. <code>l</code> keeps histogram of lengths of arrays, and <code>updated</code> is number of times an array has been observed in particular place in JSON.</p><h3 id="DictEntry"><a class="docs-heading-anchor" href="#DictEntry">DictEntry</a><a id="DictEntry-1"></a><a class="docs-heading-anchor-permalink" href="#DictEntry" title="Permalink"></a></h3><pre><code class="language-julia">mutable struct DictEntry &lt;: JSONEntry
	childs::Dict{Symbol, Any}
	updated::Int
end</code></pre><p>defers all statistics about its children to them, and the only statistic is again a counter <code>updated</code> about number of observations. Fields <code>childs</code> contains all keys which were observed in specific Dictionary and their corresponding <code>&lt;:JSONEntry</code> values with statistics about values observed under given key.</p><h3 id="MultiEntry"><a class="docs-heading-anchor" href="#MultiEntry">MultiEntry</a><a id="MultiEntry-1"></a><a class="docs-heading-anchor-permalink" href="#MultiEntry" title="Permalink"></a></h3><pre><code class="language-julia">mutable struct MultiEntry &lt;: JSONEntry
	childs::Vector{JSONEntry}
	updated::Int
end</code></pre><p>is a failsafe for cases, where the schema is not stable. For example in following two JSONs</p><pre><code class="language-json">{"a": "Hello"}
{"a": ["Hello"," world"]}</code></pre><p>the type of a value of a key <code>"a"</code> is <code>String</code>, whereas in the second it is <code>"Vector"</code>. The JsonGrinder will deal with this by first creating an <code>Entry</code>, since the value is scalar, and upon encountering the second JSON, it will replace <code>Entry</code> with <code>MultiEntry</code> having <code>Entry</code> and <code>ArrayEntry</code> as children (this is the reason why entries are declared mutable).</p><p><em>While JsonGrinder can deal with non-stable jsons, it is strongly discouraged as it might have negative effect on the performance.</em></p><p>Usefulness of such feature comes into play also when you don't know if your schema is stable or not. In that case, you can calculate the schema, and then search for <code>MultiEntry</code> nodes.</p><h3 id="Illustrative-example"><a class="docs-heading-anchor" href="#Illustrative-example">Illustrative example</a><a id="Illustrative-example-1"></a><a class="docs-heading-anchor-permalink" href="#Illustrative-example" title="Permalink"></a></h3><p>Let's say we have following jsons. We take them and create a schema.</p><pre><code class="language-julia">using JSON, JsonGrinder
jsons = [
       """{"a": "Hello", "b":{"c":1, "d":1}}""",
       """{"a": ["Hi", "Julia"], "b":{"c":1, "d":[1,2,3]}}""",
       """{"a": "World", "b":{"c":2, "d":2}}""",
]
sch = schema(JSON.parse, jsons)</code></pre><p>you can visualize schema by</p><pre><code class="language-julia">julia&gt; display(sch)
[Dict] (updated = 3)
  ├── a: [MultiEntry] (updated = 3)
  │        ├── 1: [Scalar - String], 2 unique values, updated = 2
  │        └── 2: [List] (updated = 1)
  │                 ⋮
  └── b: [Dict] (updated = 3)
           ├── c: [Scalar - Int64], 2 unique values, updated = 3
           └── d: [MultiEntry] (updated = 3)
                    ⋮</code></pre><p>which shows only reasonable part.</p><p>To see whole schema, we can use <code>printtree(ds; htrunc=Inf, vtrunc=Inf, trav=true)</code> from <a href="https://github.com/Sheemon7/HierarchicalUtils.jl">HierarchicalUtils.jl</a> which prints the whole schema, together with identifiers of individual nodes:</p><pre><code class="language-julia">julia&gt; printtree(sch; htrunc=Inf, vtrunc=Inf, trav=true)
[Dict] (updated = 3) [""]
  ├── a: [MultiEntry] (updated = 3) ["E"]
  │        ├── 1: [Scalar - String], 2 unique values, updated = 2 ["I"]
  │        └── 2: [List] (updated = 1) ["M"]
  │                 └── [Scalar - String], 2 unique values, updated = 2 ["O"]
  └── b: [Dict] (updated = 3) ["U"]
           ├── c: [Scalar - Int64], 2 unique values, updated = 3 ["Y"]
           └── d: [MultiEntry] (updated = 3) ["c"]
                    ├── 1: [Scalar - Int64], 2 unique values, updated = 2 ["d"]
                    └── 2: [List] (updated = 1) ["e"]
                             └── [Scalar - Int64], 3 unique values, updated = 3 ["eU"]</code></pre><p>Strings at the end of each row can be used as a key to access individual elements of the schema. To learn more about <a href="https://github.com/Sheemon7/HierarchicalUtils.jl">HierarchicalUtils.jl</a> check their docs or <a href="https://pevnak.github.io/Mill.jl/dev/tools/hierarchical/">section about HierarchicalUtils.jl in Mill.jl documentation</a></p><p>Here, we see that we have 2 <code>MultiEntry</code>, thus 2 type instabilities in our jsons. The first <code>MultiEntry</code> (key <code>"E"</code>) has 2 children: <code>Entry</code> and <code>ArrayEntry</code>.</p><p>The <code>sch["E"].updated</code> is 3, because value under key <code>a</code> in json has been observed 3 times. The <code>sch["I"].updated</code> is 2, because string value was seen 2 times under <code>a</code>. As expected, we can see</p><pre><code class="language-julia">julia&gt; sch["I"].counts
Dict{String,Int64} with 2 entries:
  "Hello" =&gt; 1
  "World" =&gt; 1</code></pre><p>and in the ArrayEntry we can see <code>sch["M"].updated</code> is 1, because array has been observed once in key <code>a</code>. The freqency of lengths is following:</p><pre><code class="language-julia">julia&gt; sch["M"].l
Dict{Int64,Int64} with 1 entry:
  2 =&gt; 1</code></pre><p>because we have observed one array of length 2. <code>sch["M"].items</code> is <code>Entry</code>.</p><p>The Entry (can be accessed by <code>sch["M"].items</code> or by <code>sch["O"]</code>) has fields with following values:</p><p><code>sch["O"].updated</code> is 2, because we have observed 2 elements in array under key <code>a</code>.  </p><p><code>counts</code> is</p><pre><code class="language-julia">julia&gt; sch["O"].counts
Dict{String,Int64} with 2 entries:
"Hi"    =&gt; 1
"Julia" =&gt; 1</code></pre><p>which corresponds to individual elements of an array we have observed.</p><h2 id="Extra-functions"><a class="docs-heading-anchor" href="#Extra-functions">Extra functions</a><a id="Extra-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Extra-functions" title="Permalink"></a></h2><p>While schema can be printed to REPL, it can contain quite a lot of information. Therefore <code>JsonGrinder.generate_html</code> exports it to HTML, where parts can be expanded at wish.</p><article class="docstring"><header><a class="docstring-binding" href="#JsonGrinder.generate_html" id="JsonGrinder.generate_html"><code>JsonGrinder.generate_html</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_html(sch::DictEntry; max_vals=100, max_len=1_000)
generate_html(file_name, sch::DictEntry; max_vals=100, max_len=1_000)</code></pre><p>exports schema to HTML including CSS style and JS allowing to expand / hide sub-parts of schema, countmaps, and lengthmaps.</p><p><strong>Arguments</strong></p><ul><li><code>max_vals</code> controls maximum number of exported values in countmap</li><li><code>max_len</code> controls maximum number of exported lengts of arrays</li><li><code>file_name</code> a name of file to save HTML with schema</li></ul><p><strong>Return</strong></p><p>If provided filename, it does not return anything. If not, it returns the generated HTML+CSS+JS as a String.</p><p><strong>Example</strong></p><p>You can either open the html file in any browser, or open it directly using ElectronDisplay</p><pre><code class="language-julia">using ElectronDisplay
using ElectronDisplay: newdisplay
generated_html = generate_html(sch, max_vals = 100)
display(newdisplay(), MIME{Symbol("text/html")}(), generated_html)</code></pre></div><a class="docs-sourcelink" href="https://github.com/pevnak/JsonGrinder.jl/blob/8757fa284761360b1a5058fd7c6b79ce243ab5a9/src/html_show_tools.jl#L141-L166" target="_blank">source</a></section></article><p>Schema supports merging using <code>Base.merge</code>, which facilitates parallel computation of schemas. An example might be</p><pre><code class="language-none">ThreadsX.mapreduce(schema, merge, Iterators.partition(jsons, div(length(jsons), Threads.nthreads())))</code></pre><article class="docstring"><header><a class="docstring-binding" href="#JsonGrinder.prune_json" id="JsonGrinder.prune_json"><code>JsonGrinder.prune_json</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prune_json(json, schema)</code></pre><p>Removes keys from <code>json</code> which are not part of the <code>schema</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JSON

julia&gt; j1 = JSON.parse("{\"a\": 4, \"b\": {\"a\":1, \"b\": 1}}");

julia&gt; j2 = JSON.parse("{\"a\": 4, \"b\": {\"a\":1}}");

julia&gt; sch = JsonGrinder.schema([j1,j2])
[Dict] (updated = 2)
  ├── a: [Scalar - Int64], 1 unique values, updated = 2
  └── b: [Dict] (updated = 2)
           ├── a: [Scalar - Int64], 1 unique values, updated = 2
           └── b: [Scalar - Int64], 1 unique values, updated = 1

julia&gt; j3 = Dict("a" =&gt; 4, "b" =&gt; Dict("a"=&gt;1), "c" =&gt; 1, "d" =&gt; 2)
Dict{String,Any} with 4 entries:
  "c" =&gt; 1
  "b" =&gt; Dict("a"=&gt;1)
  "a" =&gt; 4
  "d" =&gt; 2

julia&gt; JsonGrinder.prune_json(j3, sch)
Dict{Any,Any} with 2 entries:
  "b" =&gt; Dict{Any,Any}("a"=&gt;1)
  "a" =&gt; 4</code></pre><p>so the <code>JsonGrinder.prune_json</code> removes keys <code>c</code> and <code>d</code>.</p></div><a class="docs-sourcelink" href="https://github.com/pevnak/JsonGrinder.jl/blob/8757fa284761360b1a5058fd7c6b79ce243ab5a9/src/schema/schema.jl#L89-L122" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#JsonGrinder.updatemaxkeys!" id="JsonGrinder.updatemaxkeys!"><code>JsonGrinder.updatemaxkeys!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updatemaxkeys!(n::Int)</code></pre><p>limits the maximum number of keys in statistics of leaves in JSON. Default value is <code>10_000</code>.</p></div><a class="docs-sourcelink" href="https://github.com/pevnak/JsonGrinder.jl/blob/8757fa284761360b1a5058fd7c6b79ce243ab5a9/src/schema/schema.jl#L9-L13" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#JsonGrinder.updatemaxlen!" id="JsonGrinder.updatemaxlen!"><code>JsonGrinder.updatemaxlen!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">updatemaxlen!(n::Int)</code></pre><p>limits the maximum length of string values in statistics of nodes in JSON. Default value is <code>10_000</code>. Longer strings will be trimmed and their length and hash will be appended to retain the uniqueness. This is due to some strings being very long and causing the schema to be even order of magnitute larger than needed.</p></div><a class="docs-sourcelink" href="https://github.com/pevnak/JsonGrinder.jl/blob/8757fa284761360b1a5058fd7c6b79ce243ab5a9/src/schema/schema.jl#L20-L26" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../extractors/">Creating extractors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 February 2021 18:43">Thursday 4 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>