<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · JsonGrinder.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img class="docs-light-only" src="assets/logo.svg" alt="JsonGrinder.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.svg" alt="JsonGrinder.jl logo"/></a><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#A-walkthrough-of-the-example"><span>A walkthrough of the example</span></a></li></ul></li><li><a class="tocitem" href="schema/">Schema</a></li><li><a class="tocitem" href="extractors/">Creating extractors</a></li><li><a class="tocitem" href="exfunctions/">Extractor functions</a></li><li><a class="tocitem" href="automl/">AutoML</a></li><li><a class="tocitem" href="api/">API Documentation</a></li><li><a class="tocitem" href="developers/">Developers</a></li><li><a class="tocitem" href="citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pevnak/JsonGrinder.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JsonGrinder.jl"><a class="docs-heading-anchor" href="#JsonGrinder.jl">JsonGrinder.jl</a><a id="JsonGrinder.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JsonGrinder.jl" title="Permalink"></a></h1><p><strong>JsonGrinder</strong> is a collection of routines that facilitates conversion of JSON documents into structures used by <a href="https://github.com/pevnak/Mill.jl">Mill.jl</a> project.</p><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>Imagine that you want to train a classifier on data looking like this</p><pre><code class="language-json">{
  &quot;services&quot;: [
    {
      &quot;protocol&quot;: &quot;tcp&quot;,
      &quot;port&quot;: 80
    },
    {
      &quot;protocol&quot;: &quot;tcp&quot;,
      &quot;port&quot;: 443
    },
  ],
  &quot;ip&quot;: &quot;192.168.1.109&quot;,
  &quot;device_id&quot;: &quot;2717684b-3937-4644-a33a-33f4226c43ec&quot;,
  &quot;upnp&quot;: [
    {
      &quot;device_type&quot;: &quot;urn:schemas-upnp-org:device:MediaServer:1&quot;,
      &quot;services&quot;: [
        &quot;urn:upnp-org:serviceId:ContentDirectory&quot;,
        &quot;urn:upnp-org:serviceId:ConnectionManager&quot;
      ],
      &quot;manufacturer&quot;: &quot;ARRIS&quot;,
      &quot;model_name&quot;: &quot;Verizon Media Server&quot;,
      &quot;model_description&quot;: &quot;Media Server&quot;
    }
  ],
  &quot;device_class&quot;: &quot;MEDIA_BOX&quot;,
  &quot;ssdp&quot;: [
    {
      &quot;st&quot;: &quot;&quot;,
      &quot;location&quot;: &quot;http://192.168.1.109:9098/device_description.xml&quot;,
      &quot;method&quot;: &quot;&quot;,
      &quot;nt&quot;: &quot;upnp:rootdevice&quot;,
      &quot;server&quot;: &quot;ARRIS DIAL/1.7.2 UPnP/1.0 ARRIS Settop Box&quot;,
      &quot;user_agent&quot;: &quot;&quot;
    },
    {
      &quot;st&quot;: &quot;&quot;,
      &quot;location&quot;: &quot;http://192.168.1.109:8091/XD/21e13e66-1dd2-11b2-9b87-44e137a2ec6a&quot;,
      &quot;method&quot;: &quot;&quot;,
      &quot;nt&quot;: &quot;upnp:rootdevice&quot;,
      &quot;server&quot;: &quot;Allegro-Software-RomPager/5.41 UPnP/1.0 ARRIS Settop Box&quot;,
      &quot;user_agent&quot;: &quot;&quot;
    },
   ],
  &quot;mac&quot;: &quot;44:e1:37:a2:ec:c1&quot;
}</code></pre><p>and the task is to predict the value in key <code>device_class</code> (in this sample it&#39;s <code>MEDIA_BOX</code>) from the rest of the JSON.</p><p>With most machine learning libraries assuming your data being stored as tensors of a fixed dimension, or a sequence, you will have a bad time. Contrary, <code>JsonGrider.jl</code> assumes your data to be stored in a flexible JSON format and tries to automate most labor using reasonable default, but it still gives you an option to control and tweak almost everything. <code>JsonGrinder.jl</code> is built on top of <a href="https://github.com/pevnak/Mill.jl">Mill.jl</a> which itself is built on top of <a href="https://fluxml.ai/">Flux.jl</a> (we do not reinvent the wheel). <strong>Although JsonGrinder was designed for JSON files, you can easily adapt it to XML, <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a>, <a href="https://msgpack.org/index.html">MessagePack</a>, and other similar structures</strong></p><p>There are four steps to create a classifier once you load the data.</p><ol><li>Create a schema of JSON files (using <code>sch = JsonGrinder.schema</code>).</li><li>Create an extractor converting JSONs to Mill structures (<code>extractor = suggestextractor(sch))</code>). Schema <code>sch</code> from previous step is very helpful, as it helps to identify, how to convert nodes (<code>Dict</code>, <code>Array</code>) to (<code>Mill.ProductNode</code> and <code>Mill.BagNode</code>) and how to convert values in leaves to (<code>Float32</code>, <code>Vector{Float32}</code>, <code>String</code>, <code>Categorical</code>).</li><li>Create a model for your JSONs, which can be easily done by (using <code>model = reflectinmodel(sch, extractor,...)</code>)</li><li>Use your favourite methods to train the model, it is 100% compatible with <code>Flux.jl</code> tooling.</li></ol><p>The first two steps are handled by <code>JsonGrinder.jl</code> the third step by <code>Mill.jl</code> and the fourth by a combination of <code>Mill.jl</code> and <code>Flux.jl</code>.</p><p>Authors see the biggest advantage in the <code>model</code> being hierarchical and reflecting the JSON structure. Thanks to <code>Mill.jl</code>, it can handle missing values at all levels.</p><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Our idealized workflow is demonstrated in <code>examples/identification.jl</code> solving <a href="https://www.kaggle.com/c/cybersecprague2019-challenge/data">device identification challenge</a> looks as follows (for many datasets which fits in memory it suggest just to change the key with labels (<code>:device_class</code>) and names of files):</p><pre><code class="language-julia">using Flux, MLDataPattern, Mill, JsonGrinder, JSON, IterTools, Statistics, ThreadTools, StatsBase
using JsonGrinder: suggestextractor
using Mill: reflectinmodel

samples = map(readlines(&quot;/Users/tomas.pevny/Work/Presentations/JuliaMeetup/dataset/train.json&quot;)) do s
           JSON.parse(s)
       end;

labelkey = &quot;device_class&quot;
minibatchsize = 100
iterations = 10_000
neurons = 20 		# neurons per layer

targets = map(i -&gt; i[labelkey], samples)
foreach(i -&gt; delete!(i, labelkey), samples)
foreach(i -&gt; delete!(i, &quot;device_id&quot;), samples)

#####
#  Create the schema and extractor
#####
sch = schema(samples)
extractor = suggestextractor(sch)

#####
#  Convert samples to Mill structure and extract targets
#####
data = tmap(extractor, samples)
labelnames = unique(targets)

#####
#  Create the model
#####
model = reflectinmodel(sch, extractor,
	k -&gt; Dense(k, neurons, relu),
	d -&gt; SegmentedMeanMax(d),
	fsm = Dict(&quot;&quot; =&gt; k -&gt; Dense(k, length(labelnames))),
)

#####
#  Train the model
#####
function minibatch()
	idx = sample(1:length(data), minibatchsize, replace = false)
	reduce(catobs, data[idx]), Flux.onehotbatch(targets[idx], labelnames)
end

accuracy(x,y) = map(xy -&gt; labelnames[argmax(model(xy[1]).data[:])] == xy[2], x, y) |&gt; mean

cb = () -&gt; println(&quot;accuracy = &quot;, accuracy(data, targets))
ps = Flux.params(model)
loss = (x,y) -&gt; Flux.logitcrossentropy(model(x).data, y)
Flux.Optimise.train!(loss, ps, repeatedly(minibatch, iterations), ADAM(), cb = Flux.throttle(cb, 2))

#####
#  Classify test data
#####
test_samples = map(JSON.parse, readlines(&quot;data/dataset/test.json&quot;))
test_data = tmap(extractor, test_samples)
o = Flux.onecold(model(reduce(catobs, test_data)).data)
predicted_classes = labelnames[o]
</code></pre><h2 id="A-walkthrough-of-the-example"><a class="docs-heading-anchor" href="#A-walkthrough-of-the-example">A walkthrough of the example</a><a id="A-walkthrough-of-the-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-walkthrough-of-the-example" title="Permalink"></a></h2><p>Include libraries and load the data.</p><pre><code class="language-julia">using Flux, MLDataPattern, Mill, JsonGrinder, JSON, IterTools, Statistics, BenchmarkTools, ThreadTools, StatsBase
using JsonGrinder: suggestextractor
using Mill: reflectinmodel

samples = map(readlines(&quot;train.json&quot;)) do s
	JSON.parse(s)
end;</code></pre><pre><code class="language-julia">labelkey = &quot;device_class&quot;
minibatchsize = 100
iterations = 5_000
neurons = 20 		# neurons per layer</code></pre><p>Create labels and remove them from data, such that we do not use them as features. We also remove <code>device_id</code> key, such that we do not predict it</p><pre><code class="language-julia">targets = map(i -&gt; i[labelkey], samples)
foreach(i -&gt; delete!(i, labelkey), samples)
foreach(i -&gt; delete!(i, &quot;device_id&quot;), samples)</code></pre><p>Create the schema of data</p><pre><code class="language-julia">sch = JsonGrinder.schema(samples)</code></pre><p>Create the extractor converting jsons to Mill structure. The <code>suggestextractor</code> is executed below with default setting, but it allows you heavy customization.</p><pre><code class="language-julia">extractor = suggestextractor(sch)</code></pre><p>Convert jsons to mill data samples.</p><pre><code class="language-julia">data = tmap(extractor, samples)
labelnames = unique(targets)</code></pre><p>Create the model according to the data</p><pre><code class="language-julia">model = reflectinmodel(sch, extractor,
	k -&gt; Dense(k, neurons, relu),
	d -&gt; SegmentedMeanMax(d),
	fsm = Dict(&quot;&quot; =&gt; k -&gt; Dense(k, length(labelnames))),
)</code></pre><p>individual arguments of <code>reflectinmodel</code> are explained in <a href="https://pevnak.github.io/Mill.jl/dev/manual/reflectin/#Model-Reflection">Mill.jl documentation</a></p><p>Lastly, we define few handy functions and then we start training.</p><pre><code class="language-julia">function minibatch()
	idx = sample(1:length(data), minibatchsize, replace = false)
	reduce(catobs, data[idx]), Flux.onehotbatch(targets[idx], labelnames)
end

accuracy(x,y) = map(xy -&gt; labelnames[argmax(model(xy[1]).data[:])] == xy[2], x, y) |&gt; mean

cb = () -&gt; println(&quot;accuracy = &quot;, accuracy(data, targets))
ps = Flux.params(model)
loss = (x,y) -&gt; Flux.logitcrossentropy(model(x).data, y)
Flux.Optimise.train!(loss, ps, repeatedly(minibatch, iterations), ADAM(), cb = Flux.throttle(cb, 2))</code></pre><p>We should see something like</p><pre><code class="language-none">accuracy = 0.1104894138776638
accuracy = 0.45656754049666703
accuracy = 0.8238869892584534
accuracy = 0.893102614582254
accuracy = 0.9316651124235831
accuracy = 0.9554795703381342
accuracy = 0.9693468725175284
accuracy = 0.975166649397299
accuracy = 0.9758056159983421
accuracy = 0.978465098608089
accuracy = 0.9825752080958795
accuracy = 0.9840949124443062
accuracy = 0.9837495250923911
accuracy = 0.9853037681760094
accuracy = 0.9850965357648603
accuracy = 0.9861499671882016
accuracy = 0.9881359444617138
accuracy = 0.9886540254895866
accuracy = 0.9903118847787794
accuracy = 0.9901219217352261
accuracy = 0.9905363865575243
accuracy = 0.9911408144233759
accuracy = 0.9913135080993334
accuracy = 0.9903809622491624</code></pre><p>accuracy rising and obtaining over 98% on training set quite quickly.</p><p>Last part is inference on test data</p><pre><code class="language-julia">test_samples = map(JSON.parse, readlines(&quot;data/dataset/test.json&quot;))
test_data = tmap(extractor, test_samples)
o = Flux.onecold(model(reduce(catobs, test_data)).data)
predicted_classes = labelnames[o]</code></pre><p><code>predicted_classes</code> contains the predictions for our test set.</p><p>We can look at individual samples. For instance, <code>test_samples[2]</code> is</p><pre><code class="language-json">{
    &quot;mac&quot;:&quot;64:b5:c6:66:2b:ab&quot;,
    &quot;ip&quot;:&quot;192.168.1.46&quot;,
    &quot;dhcp&quot;:[
        {
            &quot;paramlist&quot;:&quot;1,3,6,15,28,33&quot;,
            &quot;classid&quot;:&quot;&quot;
        }
    ],
    &quot;device_id&quot;:&quot;addb3142-6b4a-4aef-9d00-ce7ab250c05c&quot;
}</code></pre><p>and the corresponding classification is</p><pre><code class="language-julia">julia&gt; predicted_classes[2]
&quot;GAME_CONSOLE&quot;</code></pre><p>if you want to see the probability distribution, it can be obtained by applying <code>softmax</code> to the output of the network.</p><pre><code class="language-julia">julia&gt; softmax(model(test_data[2]).data)
13×1 Array{Float32,2}:
2.2447991f-6
0.0006994973
7.356086f-5
0.9131056
0.00015438742
2.277255f-6
1.2209773f-5
0.07608723
0.0024369168
0.0012505687
0.006140974
3.3941535f-5
3.9533225f-7</code></pre><p>so we can see that the probability that given sample is <code>GAME_CONSOLE</code> is ~91% (in 4th element of array).</p><p>This concludes a simple classifier for JSON data.</p><p>But keep in mind the framework is general and given its ability to embed hierarchical data into fixed-size vectors, it can be used for classification, regression, and various other ML tasks.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="schema/">Schema »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 February 2021 17:20">Monday 1 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
