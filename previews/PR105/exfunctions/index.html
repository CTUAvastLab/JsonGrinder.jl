<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extractors overview · JsonGrinder.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="JsonGrinder.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="JsonGrinder.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../schema/">Schema</a></li><li><a class="tocitem" href="../extractors/">Creating extractors</a></li><li class="is-active"><a class="tocitem" href>Extractors overview</a><ul class="internal"><li><a class="tocitem" href="#Numbers"><span>Numbers</span></a></li><li><a class="tocitem" href="#Strings"><span>Strings</span></a></li><li><a class="tocitem" href="#Categorical"><span>Categorical</span></a></li><li><a class="tocitem" href="#Array-(Lists-/-Sets)"><span>Array (Lists / Sets)</span></a></li><li><a class="tocitem" href="#exfuctions_ExtractDict"><span>Dict</span></a></li><li class="toplevel"><a class="tocitem" href="#Specials"><span>Specials</span></a></li><li><a class="tocitem" href="#ExtractKeyAsField"><span>ExtractKeyAsField</span></a></li><li><a class="tocitem" href="#MultipleRepresentation"><span>MultipleRepresentation</span></a></li><li><a class="tocitem" href="#ExtractEmpty"><span>ExtractEmpty</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/">Examples Overview</a></li><li><a class="tocitem" href="../examples/mutagenesis/">Mutagenesis Example</a></li><li><a class="tocitem" href="../examples/recipes/">Recipe Ingredients Example</a></li><li><a class="tocitem" href="../examples/schema_examination/">Schema Examination</a></li><li><a class="tocitem" href="../examples/schema_visualization/">Schema Visualization</a></li></ul></li><li><a class="tocitem" href="../automl/">AutoML</a></li><li><a class="tocitem" href="../hierarchical/">External tools</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li><li><a class="tocitem" href="../developers/">Developers</a></li><li><a class="tocitem" href="../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Extractors overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extractors overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CTUAvastLab/JsonGrinder.jl/blob/master/docs/src/exfunctions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Extractors-overview"><a class="docs-heading-anchor" href="#Extractors-overview">Extractors overview</a><a id="Extractors-overview-1"></a><a class="docs-heading-anchor-permalink" href="#Extractors-overview" title="Permalink"></a></h1><p>Below, we first describe extractors of values (i.e. leaves of JSON tree),  then proceed to description of extractors of <code>Array</code> and <code>Dict</code>, and finish with some specials.</p><p>Extractors of scalar values are arguably the most important, but also fortunately the most understood ones.  They control, how values are converted to a <code>Vector</code> (or generally tensor) for the neural networks.  For example, they control, if number should be represented as a number, or as one-hot encoded categorical variable.  Similarly, they control how <code>String</code> should be treated, although we admit to natively support only n-grams.</p><p>Because mapping from JSON (or different hierarchical structure) to <code>Mill</code> structures can be non-trivial,  extractors have keyword argument <code>store_input</code>,  which, if <code>true</code>, causes input data to be stored as metadata of respective <code>Mill</code> structure. By default, it&#39;s false,  because it can cause type-instability in case of irregular input data and thus suffer from performance loss.  The <code>store_input</code> argument is propagated to leaves and is used to store primarily leaf values.</p><p>Because <code>JsonGrinder</code> supports working with missing values, each leaf extractor has <code>uniontypes</code> field which determines  if it can return missing values or not, and based on this field, extractor returns appropriate data type. By default, <code>uniontypes</code> is true, so it supports missing values of the shelf,  but we advise to set it during extractor construction according to your data because it may create unnecessarily many parameters otherwise.  <a href="../api/#JsonGrinder.suggestextractor"><code>suggestextractor</code></a> takes into account where missing values can be observed and where not based on statistics  in schema and provides sensible default extractor.</p><p>Recall</p><h2 id="Numbers"><a class="docs-heading-anchor" href="#Numbers">Numbers</a><a id="Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Numbers" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct ExtractScalar{T} &lt;: AbstractExtractor
	c::T
	s::T
	uniontypes::Bool
end</code></pre><p>Extracts a numerical value, centered by subtracting <code>c</code> and scaled by multiplying by <code>s</code>. Strings are converted to numbers. The extractor returns <code>ArrayNode{Matrix{T}}</code> with a single row if <code>uniontypes</code> if <code>false</code>,  and <code>ArrayNode{Matrix{Union{Missing, T}}}</code> with a single row if <code>uniontypes</code> if <code>true</code>.</p><pre><code class="language-julia hljs">e = ExtractScalar(Float32, 0.5, 4.0, true)
e(&quot;1&quot;).data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×1 Matrix{Union{Missing, Float32}}:
 2.0f0</code></pre><p><code>missing</code> value is extracted as a missing value, as it is automatically handled downstream by <code>Mill</code>.</p><pre><code class="language-julia hljs">e(missing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×1 Mill.ArrayNode{Matrix{Union{Missing, Float32}}, Nothing}:
 missing</code></pre><p>the <code>e(&quot;1&quot;)</code> is equivalent to <code>e(&quot;1&quot;, store_input=false)</code>. To see input data in metadata of <code>ArrayNode</code>, we can run</p><pre><code class="language-julia hljs">e(&quot;1&quot;, store_input=true).metadata</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×1 Matrix{String}:
 &quot;1&quot;</code></pre><p>data remain unchanged</p><pre><code class="language-julia hljs">e(&quot;1&quot;, store_input=true).data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×1 Matrix{Union{Missing, Float32}}:
 2.0f0</code></pre><p>by default, metadata contains <code>nothing</code>.</p><p>And if <code>uniontypes</code> is false, it looks as follows</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; e = ExtractScalar(Float32, 0.5, 4.0, true)</code><code class="nohighlight hljs ansi" style="display:block;">Float32</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(&quot;1&quot;).data</code><code class="nohighlight hljs ansi" style="display:block;">1×1 Matrix{Union{Missing, Float32}}:
 2.0f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(&quot;1&quot;, store_input_true=true).data</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching (::ExtractScalar{Float32})(::String; store_input_true=true)
Closest candidates are:
  (::ExtractScalar{T})(::AbstractString; store_input) where T at ~/work/JsonGrinder.jl/JsonGrinder.jl/src/extractors/extractscalar.jl:75 got unsupported keyword argument &quot;store_input_true&quot;
  (::ExtractScalar)(::Union{Missing, Nothing, JsonGrinder.ExtractEmpty, AbstractString, Number, AbstractDict, AbstractVector}; store_input) at ~/work/JsonGrinder.jl/JsonGrinder.jl/src/extractors/extractscalar.jl:70 got unsupported keyword argument &quot;store_input_true&quot;
  (::ExtractScalar{T})(!Matched::Number; store_input) where T at ~/work/JsonGrinder.jl/JsonGrinder.jl/src/extractors/extractscalar.jl:73 got unsupported keyword argument &quot;store_input_true&quot;
  ...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(&quot;1&quot;, store_input_true=true).metadata</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching (::ExtractScalar{Float32})(::String; store_input_true=true)
Closest candidates are:
  (::ExtractScalar{T})(::AbstractString; store_input) where T at ~/work/JsonGrinder.jl/JsonGrinder.jl/src/extractors/extractscalar.jl:75 got unsupported keyword argument &quot;store_input_true&quot;
  (::ExtractScalar)(::Union{Missing, Nothing, JsonGrinder.ExtractEmpty, AbstractString, Number, AbstractDict, AbstractVector}; store_input) at ~/work/JsonGrinder.jl/JsonGrinder.jl/src/extractors/extractscalar.jl:70 got unsupported keyword argument &quot;store_input_true&quot;
  (::ExtractScalar{T})(!Matched::Number; store_input) where T at ~/work/JsonGrinder.jl/JsonGrinder.jl/src/extractors/extractscalar.jl:73 got unsupported keyword argument &quot;store_input_true&quot;
  ...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(missing)</code><code class="nohighlight hljs ansi" style="display:block;">1×1 Mill.ArrayNode{Matrix{Union{Missing, Float32}}, Nothing}:
 missing</code></pre><h2 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct ExtractString &lt;: AbstractExtractor
	n::Int
	b::Int
	m::Int
	uniontypes::Bool
end</code></pre><p>Represents <code>String</code> as <code>n-</code>grams (<code>NGramMatrix</code> from <code>Mill.jl</code>) with base <code>b</code> and modulo <code>m</code>.</p><pre><code class="language-julia hljs">e = ExtractString()
e(&quot;Hello&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2053×1 Mill.ArrayNode{Mill.NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}, Nothing}:
 &quot;Hello&quot;</code></pre><p><code>missing</code> value is extracted as a missing value, as it is automatically handled downstream by <code>Mill</code>.</p><pre><code class="language-julia hljs">e(missing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2053×1 Mill.ArrayNode{Mill.NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}, Nothing}:
 missing</code></pre><p>Storing input works in the same manner as for <code>ExtractScalar</code>, see</p><pre><code class="language-julia hljs">e(&quot;Hello&quot;, store_input=true).metadata</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{String}:
 &quot;Hello&quot;</code></pre><p>it works the same also with missing values</p><pre><code class="language-julia hljs">e(missing, store_input=true).metadata</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Missing}:
 missing</code></pre><p>and if we know we won&#39;t have missing strings, we can disable <code>uniontypes</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; e = ExtractString(false)</code><code class="nohighlight hljs ansi" style="display:block;">String</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(&quot;Hello&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">2053×1 Mill.ArrayNode{Mill.NGramMatrix{String, Vector{String}, Int64}, Nothing}:
 &quot;Hello&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(missing)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: This extractor does not support missing values</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e(&quot;Hello&quot;, store_input=true).metadata</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;Hello&quot;</code></pre><h2 id="Categorical"><a class="docs-heading-anchor" href="#Categorical">Categorical</a><a id="Categorical-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct ExtractCategorical{V,I} &lt;: AbstractExtractor
	keyvalemap::Dict{V,I}
	n::Int
	uniontypes::Bool
end</code></pre><p>Converts a single item to a one-hot encoded vector. For a safety, there is always an extra item reserved for an unknown value.</p><pre><code class="language-julia hljs">e = ExtractCategorical([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])
e([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;]).data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×1 MaybeHotMatrix with eltype Union{Missing, Bool}:
 missing
 missing
 missing
 missing</code></pre><p><code>missing</code> value is extracted as a missing value, as it is automatically handled downstream by <code>Mill</code>.</p><pre><code class="language-julia hljs">e(missing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×1 Mill.ArrayNode{Mill.MaybeHotMatrix{Union{Missing, UInt32}, UInt32, Union{Missing, Bool}}, Nothing}:
 missing
 missing
 missing
 missing</code></pre><p>Storing input in this case looks as follows</p><pre><code class="language-julia hljs">e([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;], store_input=true).metadata</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Vector{String}}:
 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</code></pre><p><code>uniontypes</code> settings works the same as with scalars or strings.</p><h3 id="Use-cases-for-unknown-value"><a class="docs-heading-anchor" href="#Use-cases-for-unknown-value">Use-cases for unknown value</a><a id="Use-cases-for-unknown-value-1"></a><a class="docs-heading-anchor-permalink" href="#Use-cases-for-unknown-value" title="Permalink"></a></h3><p>The last dimension for unknown value can be used e.g. to represent sparse data, where values which are frequent have their own dimension, and all values which are scarce will share this single dimension. This is useful for heavy-tail  distributions where many dimensions would be used only rarely, but would raise the number of trained parameters significantly.</p><p>Of course if all values in the training set are represented explicitly and unknown value is not present during training,  the model will not learn the unknown representation, and it will produce noise in case of unknown value in inference time.</p><p>Examples of schema with heavy tail can be following histogram with exponential number of observations</p><pre><code class="language- hljs">ht_hist = Dict((i==1 ? &quot;aaaaa&quot; : randstring(5))=&gt;ceil(100*ℯ^(-i/5)) for i in 1:1000)
e = JsonGrinder.Entry{String}(ht_hist, sum(values(ht_hist)))</code></pre><p>Now we can see it has 1000 unique values, and has been created from 1437 observations, where 977 values were observed only once. Creating the extractor directly and extracting value from it will produce one-hot encoded vector of dimension 1001 (1000 unique values + 1 dimension for the unknown).</p><pre><code class="language- hljs">ExtractCategorical(e)(&quot;aaaaa&quot;)</code></pre><p>But when making threshold for values we have seen at least 5 times, it produces one-hot vector of dimension 17, which is significantly smaller.</p><pre><code class="language- hljs">ExtractCategorical(keys(filter(kv-&gt;kv[2]&gt;=5, e.counts)))(&quot;aaaaa&quot;)</code></pre><p>For training, the latter approach may be beneficial, because the number of weights will be significantly lower.</p><h3 id="Difference-between-unknown-and-missing-value"><a class="docs-heading-anchor" href="#Difference-between-unknown-and-missing-value">Difference between unknown and missing value</a><a id="Difference-between-unknown-and-missing-value-1"></a><a class="docs-heading-anchor-permalink" href="#Difference-between-unknown-and-missing-value" title="Permalink"></a></h3><p>Note that there is semantic difference between unknown and <code>missing</code> value. For unknown value, special dimension is trained. For the missing one, it&#39;s similar, every time missing value is encountered in specific layer, the neural network contains vector it trains instead and which is used as an output in case of missing observation. This allows the model to distinguish between missing values (e.g. when the key in dict is not present, the value under that key is tretated as missing) and unknown, previously unseen values.</p><h2 id="Array-(Lists-/-Sets)"><a class="docs-heading-anchor" href="#Array-(Lists-/-Sets)">Array (Lists / Sets)</a><a id="Array-(Lists-/-Sets)-1"></a><a class="docs-heading-anchor-permalink" href="#Array-(Lists-/-Sets)" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct ExtractArray{T}
	item::T
end</code></pre><p>Convert array of values to a <code>Mill.BagNode</code> with items converted by <code>item</code>. The entire array is assumed to be a single bag.</p><pre><code class="language-julia hljs">sc = ExtractArray(ExtractCategorical([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]))
sc([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BagNode 	# 1 obs, 88 bytes
  └── ArrayNode(4×4 MaybeHotMatrix with Union{Missing, Bool} elements) 	# 4 obs, 92 bytes</code></pre><p>Empty arrays are represented as an empty bag.</p><pre><code class="language-julia hljs">sc([]).bags</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Mill.AlignedBags{Int64}(UnitRange{Int64}[0:-1])</code></pre><p>The data of empty bag can be either <code>missing</code> or a empty sample, which is more convenient as it makes all samples of the same type,  which is nicer to AD. This behavior is controlled by <code>Mill.emptyismissing</code>.  The extractor of a <code>BagNode</code> can signal to child extractors to extract a sample with zero observations using  a special singleton <code>JsonGrinder.extractempty</code>.  For example</p><pre><code class="language-julia hljs">Mill.emptyismissing!(true)
sc([]).data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">missing</code></pre><pre><code class="language-julia hljs">Mill.emptyismissing!(false)
sc([]).data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×0 Mill.ArrayNode{Mill.MaybeHotMatrix{Union{Missing, UInt32}, UInt32, Union{Missing, Bool}}, Nothing}</code></pre><p>Storing input is delegated to leaf extractors, so metadata of bag itself are empty</p><pre><code class="language-julia hljs">sc([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;], store_input=true).metadata</code></pre><p>but metadata of underlying <code>ArrayNode</code> contain inputs.</p><pre><code class="language-julia hljs">sc([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;], store_input=true).data.metadata</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;D&quot;</code></pre><p>In case of empty arrays, input is stored in metadata of <code>BagNode</code> itself, because there might not be any underlying <code>ArrayNode</code>.</p><pre><code class="language-julia hljs">sc([], store_input=true).metadata</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Vector{Any}}:
 []</code></pre><h2 id="exfuctions_ExtractDict"><a class="docs-heading-anchor" href="#exfuctions_ExtractDict">Dict</a><a id="exfuctions_ExtractDict-1"></a><a class="docs-heading-anchor-permalink" href="#exfuctions_ExtractDict" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct ExtractDict{S} &lt;: AbstractExtractor
	dict::S
end</code></pre><p>Extracts all items in <code>dict</code> and return them as a ProductNode. Key in dict corresponds to keys in JSON.</p><pre><code class="language-julia hljs">ex = ExtractDict(Dict(:a =&gt; ExtractScalar(),
	:b =&gt; ExtractString(),
	:c =&gt; ExtractCategorical([&quot;A&quot;,&quot;B&quot;]),
	:d =&gt; ExtractArray(ExtractString())))
ex(Dict(:a =&gt; &quot;1&quot;,
	:b =&gt; &quot;Hello&quot;,
	:c =&gt; &quot;A&quot;,
	:d =&gt; [&quot;Hello&quot;, &quot;world&quot;]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductNode 	# 1 obs, 96 bytes
  ├── a: ArrayNode(1×1 Array with Union{Missing, Float32} elements) 	# 1 obs, 53 bytes
  ├── b: ArrayNode(2053×1 NGramMatrix with Union{Missing, Int64} elements) 	# 1 obs, 125 bytes
  ├── d: BagNode 	# 1 obs, 104 bytes
  │        └── ArrayNode(2053×2 NGramMatrix with Union{Missing, Int64} elements) 	# 2 obs, 146 bytes
  └── c: ArrayNode(3×1 MaybeHotMatrix with Union{Missing, Bool} elements) 	# 1 obs, 77 bytes</code></pre><p>Missing keys are replaced by <code>missing</code> and handled by child extractors.</p><pre><code class="language-julia hljs">ex(Dict(:a =&gt; &quot;1&quot;,
	:c =&gt; &quot;A&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductNode 	# 1 obs, 96 bytes
  ├── a: ArrayNode(1×1 Array with Union{Missing, Float32} elements) 	# 1 obs, 53 bytes
  ├── b: ArrayNode(2053×1 NGramMatrix with Union{Missing, Int64} elements) 	# 1 obs, 112 bytes
  ├── d: BagNode 	# 1 obs, 104 bytes
  │        └── ArrayNode(2053×0 NGramMatrix with Union{Missing, Int64} elements) 	# 0 obs, 104 bytes
  └── c: ArrayNode(3×1 MaybeHotMatrix with Union{Missing, Bool} elements) 	# 1 obs, 77 bytes</code></pre><p>Storing input data works in similar manner as for <code>ExtractArray</code>, input data are delegated to leaf extractors.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:c =&gt; &quot;A&quot;), store_input=true).metadata</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:c =&gt; &quot;A&quot;), store_input=true)[:a].metadata</code><code class="nohighlight hljs ansi" style="display:block;">1×1 Matrix{String}:
 &quot;1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:c =&gt; &quot;A&quot;), store_input=true)[:b].metadata</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Nothing}:
 nothing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:c =&gt; &quot;A&quot;), store_input=true)[:c].metadata</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;A&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:c =&gt; &quot;A&quot;), store_input=true)[:d].metadata</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Nothing}:
 nothing</code></pre><p>or</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:b =&gt; &quot;Hello&quot;,
       	:c =&gt; &quot;A&quot;,
       	:d =&gt; [&quot;Hello&quot;, &quot;world&quot;]), store_input=true).metadata</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:b =&gt; &quot;Hello&quot;,
       	:c =&gt; &quot;A&quot;,
       	:d =&gt; [&quot;Hello&quot;, &quot;world&quot;]), store_input=true)[:a].metadata</code><code class="nohighlight hljs ansi" style="display:block;">1×1 Matrix{String}:
 &quot;1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:b =&gt; &quot;Hello&quot;,
       	:c =&gt; &quot;A&quot;,
       	:d =&gt; [&quot;Hello&quot;, &quot;world&quot;]), store_input=true)[:b].metadata</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;Hello&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:b =&gt; &quot;Hello&quot;,
       	:c =&gt; &quot;A&quot;,
       	:d =&gt; [&quot;Hello&quot;, &quot;world&quot;]), store_input=true)[:c].metadata</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{String}:
 &quot;A&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:b =&gt; &quot;Hello&quot;,
       	:c =&gt; &quot;A&quot;,
       	:d =&gt; [&quot;Hello&quot;, &quot;world&quot;]), store_input=true)[:d].metadata</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(Dict(:a =&gt; &quot;1&quot;,
       	:b =&gt; &quot;Hello&quot;,
       	:c =&gt; &quot;A&quot;,
       	:d =&gt; [&quot;Hello&quot;, &quot;world&quot;]), store_input=true)[:d].data.metadata</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;Hello&quot;
 &quot;world&quot;</code></pre><h1 id="Specials"><a class="docs-heading-anchor" href="#Specials">Specials</a><a id="Specials-1"></a><a class="docs-heading-anchor-permalink" href="#Specials" title="Permalink"></a></h1><h2 id="ExtractKeyAsField"><a class="docs-heading-anchor" href="#ExtractKeyAsField">ExtractKeyAsField</a><a id="ExtractKeyAsField-1"></a><a class="docs-heading-anchor-permalink" href="#ExtractKeyAsField" title="Permalink"></a></h2><p>Some JSONs we have encountered use <code>Dict</code>s to hold an array of named lists (or other types).  Having computer security background a prototypical example is storing a list of DLLs with a corresponding list of  imported function in a single structure.  For example a JSON</p><pre><code class="language-json hljs">{ &quot;foo.dll&quot; : [&quot;print&quot;,&quot;write&quot;, &quot;open&quot;,&quot;close&quot;],
  &quot;bar.dll&quot; : [&quot;send&quot;, &quot;recv&quot;]
}</code></pre><p>should be better written as</p><pre><code class="language-json hljs">[{&quot;key&quot;: &quot;foo.dll&quot;,
  &quot;item&quot;: [&quot;print&quot;,&quot;write&quot;, &quot;open&quot;,&quot;close&quot;]},
  {&quot;key&quot;: &quot;bar.dll&quot;,
  &quot;item&quot;: [&quot;send&quot;, &quot;recv&quot;]}
]</code></pre><p>JsonGrinder tries to detect these cases, as they are typically manifested by <code>Dicts</code> with excessively large number of keys in a schema.  The detection logic of this case in <code>suggestextractor(e::DictEntry)</code> is simple, if the number of unique keys in a specific  <code>Dict</code> is greater than <code>settings.key_as_field = 500</code>, such <code>Dict</code> is considered to hold values in keys and  <code>ExtractKeyAsField</code> is used instead of <code>ExtractDict</code>.  <code>key_as_field</code> can be set to any value based on specific data or domain, but we have found <code>500</code> to be reasonable default.</p><p>The extractor itself is simple as well. For the case above, it would look like</p><pre><code class="language-julia hljs">s = JSON.parse(&quot;{ \&quot;foo.dll\&quot; : [\&quot;print\&quot;,\&quot;write\&quot;, \&quot;open\&quot;,\&quot;close\&quot;],
  \&quot;bar.dll\&quot; : [\&quot;send\&quot;, \&quot;recv\&quot;]
}&quot;)
ex = ExtractKeyAsField(ExtractString(),ExtractArray(ExtractString()))
ex(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BagNode 	# 1 obs, 144 bytes
  └── ProductNode 	# 2 obs, 72 bytes
        ├─── key: ArrayNode(2053×2 NGramMatrix with Union{Missing, Int64} elements) 	# 2 obs, 150 bytes
        └── item: BagNode 	# 2 obs, 120 bytes
                    ⋮</code></pre><p>As you might expect, inputs are stored in leaf metadata if needed</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(s, store_input=true).metadata</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Dict{String, Any}}:
 Dict(&quot;bar.dll&quot; =&gt; Any[&quot;send&quot;, &quot;recv&quot;], &quot;foo.dll&quot; =&gt; Any[&quot;print&quot;, &quot;write&quot;, &quot;open&quot;, &quot;close&quot;])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(s, store_input=true).data[:key].metadata</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{String}:
 &quot;bar.dll&quot;
 &quot;foo.dll&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex(s, store_input=true).data[:item].data.metadata</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{String}:
 &quot;send&quot;
 &quot;recv&quot;
 &quot;print&quot;
 &quot;write&quot;
 &quot;open&quot;
 &quot;close&quot;</code></pre><p>Because it returns <code>BagNode</code>, missing values are treated in similar manner as in <code>ExtractArray</code> and settings of <code>Mill.emptyismissing</code> applies here too.</p><pre><code class="language-julia hljs">Mill.emptyismissing!(true)
ex(Dict()).data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">missing</code></pre><pre><code class="language-julia hljs">Mill.emptyismissing!(false)
ex(Dict()).data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductNode 	# 0 obs, 72 bytes
  ├─── key: ArrayNode(2053×0 NGramMatrix with Union{Missing, Int64} elements) 	# 0 obs, 104 bytes
  └── item: BagNode 	# 0 obs, 88 bytes
              └── ArrayNode(2053×0 NGramMatrix with Union{Missing, Int64} elements) 	# 0 obs, 104 bytes</code></pre><h2 id="MultipleRepresentation"><a class="docs-heading-anchor" href="#MultipleRepresentation">MultipleRepresentation</a><a id="MultipleRepresentation-1"></a><a class="docs-heading-anchor-permalink" href="#MultipleRepresentation" title="Permalink"></a></h2><p>Provides a way to have multiple representations for a single value or subtree in JSON.  For example imagine that are extracting strings with some very frequently occurring values and a lots of clutter,  which might be important and you do not know about it.  <code>MultipleRepresentation(extractors::Tuple)</code> contains a <code>Tuple</code> or <code>NamedTuple</code> of extractors and apply them to a single sub-tree in a json.  The corresponding <code>Mill</code> structure will contain <code>ProductNode</code> of both representation.</p><p>For example <code>String</code> with <em>Categorical</em> and <em>NGram</em> representation will look like</p><pre><code class="language-julia hljs">ex = MultipleRepresentation((c = ExtractCategorical([&quot;Hello&quot;,&quot;world&quot;]), s = ExtractString()))
reduce(catobs,ex.([&quot;Hello&quot;,&quot;world&quot;,&quot;from&quot;,&quot;Prague&quot;]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductNode 	# 4 obs, 48 bytes
  ├── c: ArrayNode(3×4 MaybeHotMatrix with Union{Missing, Bool} elements) 	# 4 obs, 92 bytes
  └── s: ArrayNode(2053×4 NGramMatrix with Union{Missing, Int64} elements) 	# 4 obs, 188 bytes</code></pre><p>Because it produces <code>ProductNode</code>, missing values are delegated to leaf extractors.</p><pre><code class="language-julia hljs">ex(missing)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ProductNode 	# 1 obs, 48 bytes
  ├── c: ArrayNode(3×1 MaybeHotMatrix with Union{Missing, Bool} elements) 	# 1 obs, 77 bytes
  └── s: ArrayNode(2053×1 NGramMatrix with Union{Missing, Int64} elements) 	# 1 obs, 112 bytes</code></pre><p><code>MultipleRepresentation</code> together with handling of <code>missing</code> values enables <code>JsonGrinder</code> to deal with JSONs with non-stable schema.</p><p>Minimalistic example of such non-stable schema can be json which sometimes has string and sometimes has array of numbers under same key.  Let&#39;s create appropriate <code>MultipleRepresentation</code> (although in real-world usage most suitable <code>MultipleRepresentation</code>  is proposed based on observed data in <code>suggestextractor</code>):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex = MultipleRepresentation((ExtractString(), ExtractArray(ExtractScalar(Float32))));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_hello = ex(&quot;Hello&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode 	# 1 obs, 48 bytes
  ├── e1: ArrayNode(2053×1 NGramMatrix with Union{Missing, Int64} elements) 	# 1 obs, 125 bytes
  └── e2: BagNode 	# 1 obs, 80 bytes
            └── ArrayNode(1×0 Array with Union{Missing, Float32} elements) 	# 0 obs, 48 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_hello[:e1].data</code><code class="nohighlight hljs ansi" style="display:block;">2053×1 Mill.NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}:
 &quot;Hello&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_hello[:e2].data</code><code class="nohighlight hljs ansi" style="display:block;">1×0 Mill.ArrayNode{Matrix{Union{Missing, Float32}}, Nothing}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_123 = ex([1,2,3])</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode 	# 1 obs, 48 bytes
  ├── e1: ArrayNode(2053×1 NGramMatrix with Union{Missing, Int64} elements) 	# 1 obs, 112 bytes
  └── e2: BagNode 	# 1 obs, 80 bytes
            └── ArrayNode(1×3 Array with Union{Missing, Float32} elements) 	# 3 obs, 63 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_123[:e1].data</code><code class="nohighlight hljs ansi" style="display:block;">2053×1 Mill.NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}:
 missing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_123[:e2].data</code><code class="nohighlight hljs ansi" style="display:block;">1×3 Mill.ArrayNode{Matrix{Union{Missing, Float32}}, Nothing}:
 1.0f0  2.0f0  3.0f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_2 = ex([2])</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode 	# 1 obs, 48 bytes
  ├── e1: ArrayNode(2053×1 NGramMatrix with Union{Missing, Int64} elements) 	# 1 obs, 112 bytes
  └── e2: BagNode 	# 1 obs, 80 bytes
            └── ArrayNode(1×1 Array with Union{Missing, Float32} elements) 	# 1 obs, 53 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_2[:e1].data</code><code class="nohighlight hljs ansi" style="display:block;">2053×1 Mill.NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}:
 missing</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_2[:e2].data</code><code class="nohighlight hljs ansi" style="display:block;">1×1 Mill.ArrayNode{Matrix{Union{Missing, Float32}}, Nothing}:
 2.0f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_world = ex(&quot;world&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode 	# 1 obs, 48 bytes
  ├── e1: ArrayNode(2053×1 NGramMatrix with Union{Missing, Int64} elements) 	# 1 obs, 125 bytes
  └── e2: BagNode 	# 1 obs, 80 bytes
            └── ArrayNode(1×0 Array with Union{Missing, Float32} elements) 	# 0 obs, 48 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_world[:e1].data</code><code class="nohighlight hljs ansi" style="display:block;">2053×1 Mill.NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}:
 &quot;world&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; e_world[:e2].data</code><code class="nohighlight hljs ansi" style="display:block;">1×0 Mill.ArrayNode{Matrix{Union{Missing, Float32}}, Nothing}</code></pre><p>in this example we can see that every time one representation is always missing, and the other one contains data.</p><h2 id="ExtractEmpty"><a class="docs-heading-anchor" href="#ExtractEmpty">ExtractEmpty</a><a id="ExtractEmpty-1"></a><a class="docs-heading-anchor-permalink" href="#ExtractEmpty" title="Permalink"></a></h2><p>As mentioned in earlier, <code>ExtractEmpty</code> is a type used to extract observation with 0 samples.  There is singleton <code>extractempty</code> which can be used to obtain instance of instance of <code>ExtractEmpty</code> type. <code>StatsBase.nobs(ex(JsonGrinder.extractempty)) == 0</code> is required to hold for every extractor in order to work correctly.</p><p>All above-mentioned extractors are able to extract this, as we can see here</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractString()(JsonGrinder.extractempty)</code><code class="nohighlight hljs ansi" style="display:block;">2053×0 Mill.ArrayNode{Mill.NGramMatrix{Union{Missing, String}, Vector{Union{Missing, String}}, Union{Missing, Int64}}, Nothing}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractString()(JsonGrinder.extractempty) |&gt; nobs</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractCategorical([&quot;A&quot;,&quot;B&quot;])(JsonGrinder.extractempty)</code><code class="nohighlight hljs ansi" style="display:block;">3×0 Mill.ArrayNode{Mill.MaybeHotMatrix{Union{Missing, UInt32}, UInt32, Union{Missing, Bool}}, Nothing}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractCategorical([&quot;A&quot;,&quot;B&quot;])(JsonGrinder.extractempty) |&gt; nobs</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractScalar()(JsonGrinder.extractempty)</code><code class="nohighlight hljs ansi" style="display:block;">1×0 Mill.ArrayNode{Matrix{Union{Missing, Float32}}, Nothing}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractScalar()(JsonGrinder.extractempty) |&gt; nobs</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractArray(ExtractString())(JsonGrinder.extractempty)</code><code class="nohighlight hljs ansi" style="display:block;">BagNode 	# 0 obs, 88 bytes
  └── ArrayNode(2053×0 NGramMatrix with Union{Missing, Int64} elements) 	# 0 obs, 104 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractArray(ExtractString())(JsonGrinder.extractempty) |&gt; nobs</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractDict(Dict(:a =&gt; ExtractScalar(),
       	:b =&gt; ExtractString(),
       	:c =&gt; ExtractCategorical([&quot;A&quot;,&quot;B&quot;]),
       	:d =&gt; ExtractArray(ExtractString())))(JsonGrinder.extractempty)</code><code class="nohighlight hljs ansi" style="display:block;">ProductNode 	# 0 obs, 96 bytes
  ├── a: ArrayNode(1×0 Array with Union{Missing, Float32} elements) 	# 0 obs, 48 bytes
  ├── b: ArrayNode(2053×0 NGramMatrix with Union{Missing, Int64} elements) 	# 0 obs, 104 bytes
  ├── d: BagNode 	# 0 obs, 88 bytes
  │        └── ArrayNode(2053×0 NGramMatrix with Union{Missing, Int64} elements) 	# 0 obs, 104 bytes
  └── c: ArrayNode(3×0 MaybeHotMatrix with Union{Missing, Bool} elements) 	# 0 obs, 72 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExtractDict(Dict(:a =&gt; ExtractScalar(),
       	:b =&gt; ExtractString(),
       	:c =&gt; ExtractCategorical([&quot;A&quot;,&quot;B&quot;]),
       	:d =&gt; ExtractArray(ExtractString())))(JsonGrinder.extractempty) |&gt; nobs</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../extractors/">« Creating extractors</a><a class="docs-footer-nextpage" href="../examples/">Examples Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 7 January 2022 17:25">Friday 7 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
