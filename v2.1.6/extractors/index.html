<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Creating extractors · JsonGrinder.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function () {
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';
        document.getElementsByTagName('head')[0].appendChild(meta);
    };
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; width: 100%; top: 0; left: 0; box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border-bottom: 1px solid #d54625; padding: 10px 35px; text-align: center; font-size: 15px;');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: calc(50% - 8px); right: 18px; cursor: pointer; width: 12px;');
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '" style="color: rgb(46, 99, 184)">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
});
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="JsonGrinder.jl logo" class="docs-light-only" src="../assets/logo.svg"/><img alt="JsonGrinder.jl logo" class="docs-dark-only" src="../assets/logo-dark.svg"/></a><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../schema/">Schema</a></li><li class="is-active"><a class="tocitem" href="">Creating extractors</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Manual-creation-of-extractors"><span>Manual creation of extractors</span></a></li><li class="toplevel"><a class="tocitem" href="#Semi-automatic-creation-of-extractors"><span>Semi-automatic creation of extractors</span></a></li><li><a class="tocitem" href="#Scalars"><span>Scalars</span></a></li><li><a class="tocitem" href="#Arrays"><span>Arrays</span></a></li><li><a class="tocitem" href="#Dict"><span>Dict</span></a></li><li><a class="tocitem" href="#Modifying-extractor"><span>Modifying extractor</span></a></li></ul></li><li><a class="tocitem" href="../exfunctions/">Extractors overview</a></li><li><a class="tocitem" href="../automl/">AutoML</a></li><li><a class="tocitem" href="../hierarchical/">External tools</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li><li><a class="tocitem" href="../developers/">Developers</a></li><li><a class="tocitem" href="../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Creating extractors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Creating extractors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CTUAvastLab/JsonGrinder.jl/blob/master/docs/src/extractors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-an-Extractor"><a class="docs-heading-anchor" href="#Creating-an-Extractor">Creating an Extractor</a><a id="Creating-an-Extractor-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Extractor" title="Permalink"></a></h1><p>Extractor is responsible for converting json to <code>Mill</code> structures. The main design idea is that the extractor for a whole json is created by composing (sub-)extractors while reflecting the JSON structure. This composability is achieved by the <strong>commitment</strong> of each extractor returning a subtype of <code>Mill.AbstractDataNode</code>. Extractor can be any function, but to ensure a composability, it is should be a subtype of <code>AbstractExtractor</code>, which means all of them are implemented as functors (also because they contain parameters).</p><h1 id="Manual-creation-of-extractors"><a class="docs-heading-anchor" href="#Manual-creation-of-extractors">Manual creation of extractors</a><a id="Manual-creation-of-extractors-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-creation-of-extractors" title="Permalink"></a></h1><p>The simplest way to create a custom extractor is the compose it from provided extractor functions. Imagine for example json file as follows.</p><pre><code class="language-json">{"name": "Karl",
 "siblings": ["Gertruda", "Heike", "Fritz"],
 "hobby": ["running", "pingpong"],
 "age": 21
}</code></pre><p>A corresponding extractor might look like</p><pre><code class="language-julia">ex = ExtractDict(Dict(
	:name =&gt; ExtractString(),
	:siblings =&gt; ExtractArray(ExtractString()),
	:hobby =&gt; ExtractArray(ExtractCategorical(["running", "swimming","yoga"])),
	:age =&gt; ExtractScalar(),
))</code></pre><pre class="documenter-example-output">Dict
  ├─────── age: Float32
  ├───── hobby: Array of
  │               └── Categorical d = 4
  ├────── name: String
  └── siblings: Array of
                  └── String</pre><p>Notice, how the composability of extractors simplifies the desing and allow to reflect the same feature of JSON documents.</p><p>Applying the extractor <code>ex</code> on the above json yields the corresponding <code>Mill</code> structure.</p><pre><code class="language-julia">s = JSON.parse("{\"name\" : \"Karl\",
 \"siblings\" : [\"Gertruda\", \"Heike\", \"Fritz\"],
 \"hobby\" : [\"running\", \"pingpong\"],
 \"age\" : 21
}")
ex(s)</code></pre><pre class="documenter-example-output">ProductNode with 1 obs
  ├─────── age: ArrayNode(1×1 Array with Float32 elements) with 1 obs
  ├───── hobby: BagNode with 1 obs
  │               └── ArrayNode(4×2 MaybeHotMatrix with Bool elements) with 2 obs
  ⋮
  └── siblings: BagNode with 1 obs
                  └── ArrayNode(2053×3 NGramMatrix with Int64 elements) with 3 obs</pre><p>The list of all extractors that we have found handy during our experiments and are part of <code>JsonGrinder</code> can be found in <a href="../exfunctions/#Extractors-overview">Extractors overview</a>.</p><h1 id="Semi-automatic-creation-of-extractors"><a class="docs-heading-anchor" href="#Semi-automatic-creation-of-extractors">Semi-automatic creation of extractors</a><a id="Semi-automatic-creation-of-extractors-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-automatic-creation-of-extractors" title="Permalink"></a></h1><p>Manually creating extractors is boring and error-prone process. Function <code>suggestextractor(schema)</code> tries to simplify this, since creation of most of the extractors is straightforward, once the schema is known.</p><p>This is especially true for <code>Dict</code> and <code>Arrays</code>, while extractors for leaves can be tricky, as one needs to decide, if the leaf should be represented as a <code>Scalar</code> and <code>String</code> or as <code>Categorical</code> variable.</p><p><code>suggestextractor(schema, settings)</code> uses a simple heuristic (described below) for choosing reasonable extractors, but it can make errors. It is therefore <strong>highly recommended</strong> to check the proposed extractor manually, if it makes sense. A typical error, especially if schema is created from a small number of samples, is that some variable is treated as a <code>Categorical</code>, while it should be <code>String</code> / <code>Scalar</code>.</p><p>Extractor for <code>Dict</code> can be configured to use either <code>ExtractDict</code> or <code>ExtractKeyAsField</code> based on properties number of keys in schema.</p><p>Extractor for <code>Array</code> is not configurable, as we do not feel the pressure to so, as there does not seems to be much to do.</p><pre><code class="language-julia">JsonGrinder.suggestextractor(schema, settings = NamedTuple())</code></pre><p>allows to pass following parameters inside the <code>settings</code> argument</p><ul><li>scalar_extractors</li><li>key<em>as</em>field</li><li>mincountkey</li></ul><p><code>scalar_extractors</code> allows to pass your own heuristic and rules for handling scalars.</p><p>By default, it's <code>settings = (; scalar_extractors = default_scalar_extractor())</code>.</p><p><code>key_as_field</code> is an <code>Int</code> parameter which configures how <code>Dict</code>s are extracted. If number of unique keys in dict is &gt;= <code>key_as_field</code>, <a href="../exfunctions/#ExtractKeyAsField">ExtractKeyAsField</a> is used, otherwise <a href="../exfunctions/#exfuctions_ExtractDict">ExtractDict</a> is used.</p><p>By default, it's <code>settings = (; key_as_field = 500)</code>.</p><p><code>minkountkey</code> is an <code>Int</code> parameter which allows you to skip sparse keys in <code>Dict</code> to avoid creation of unnecessarily large model. <code>minkountkey</code> contains minimum number of observations of the key in schema to be included in extractor. All keys, whose <code>updated</code> field in schema for specific key is &gt; <code>minkountkey</code> are included in resulting <code>ExtractDict</code>. This settings applies only to <code>Dict</code>s which are not consideted to be "key as field". If a certain <code>Dict</code> is considered to be extracted by <code>ExtractKeyAsField</code>, <code>minkountkey</code> does not apply to it.</p><p>By default, it's <code>settings = (; minkountkey = 0)</code>, thus no keys are omitted by default.</p><h2 id="Scalars"><a class="docs-heading-anchor" href="#Scalars">Scalars</a><a id="Scalars-1"></a><a class="docs-heading-anchor-permalink" href="#Scalars" title="Permalink"></a></h2><p><code>scalar_extractors</code> is a list of tuples, where the first is a condition and the second is a function creating the extractor in case of a true. The default heuristic is following and you can adjust according to your liking.</p><pre><code class="language-julia">function default_scalar_extractor()
	[
	(e -&gt; length(keys(e)) &lt;= 100 &amp;&amp; (is_intable(e) || is_floatable(e)),
		e -&gt; ExtractCategorical(keys(e))),
	(e -&gt; is_intable(e),
		e -&gt; extractscalar(Int32, e)),
	(e -&gt; is_floatable(e),
	 	e -&gt; extractscalar(FloatType, e)),
	# it's important that condition here would be lower than maxkeys
	(e -&gt; (keys_len = length(keys(e)); keys_len / e.updated &lt; 0.1 &amp;&amp; keys_len &lt; 10000 &amp;&amp; !(is_intable(e) || is_floatable(e))),
		e -&gt; ExtractCategorical(keys(e))),
	(e -&gt; true,
		e -&gt; extractscalar(unify_types(e), e)),]
end</code></pre><p>Note that order matters here, as the extractors are suggested using following logic</p><pre><code class="language-julia">for (c, ex) in get(settings, :scalar_extractors, default_scalar_extractor())
	c(e) &amp;&amp; return ex(e)
end</code></pre><h2 id="Arrays"><a class="docs-heading-anchor" href="#Arrays">Arrays</a><a id="Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays" title="Permalink"></a></h2><p>Extractor suggested for <code>ArrayEntry</code> is most of the time <code>ExtractArray</code> converting <code>Array</code>s to <code>Mill.BagNode</code>s. The exception is the case, when vectors are of the same length and their items are numbers. In this case, the <code>suggestextractor</code> returns <code>ExtractVector</code>, which treats convert the array to a <code>Mill.ArrayNode</code>, as we believe the array to represent a feature vector.</p><h2 id="Dict"><a class="docs-heading-anchor" href="#Dict">Dict</a><a id="Dict-1"></a><a class="docs-heading-anchor-permalink" href="#Dict" title="Permalink"></a></h2><p>Extractor suggested for <code>DictEntry</code> is most of the time <code>ExtractDict</code> converting <code>Dict</code>s to <code>ProductNode</code>s. As mentioned above, there is an excetion. Sometimes, people use <code>Dict</code>s with names of keys being values. For example consider following two jsons</p><pre><code class="language-json">{"a.dll": ["f", "g", "h"],
 "b.dll": ["a", "b", "c"]}
{"c.dll": ["x", "y", "z"]}</code></pre><p>in the case, keys <code>["a.dll","b.dll","c.dll"]</code> are actually values (names of libraries), and arrays are values as well. The dictionary therefore contain an array. If this case is detected, it is suggested to use <code>ExtractKeyAsField</code>, which interprets the above JSON as</p><pre><code class="language-json">[{"key": "a.dll",
  "field": ["f", "g", "h"]},
 {"key": "b.dll",
 "field": ["a", "b", "c"]}
]
[{"key": "c.dll",
"field": ["x", "y", "z"]}]</code></pre><p>To demonstrate difference between them, let's compare resulting <code>Mill</code> structures.</p><pre><code class="language-julia-repl">julia&gt; s1 = JSON.parse("{\"a.dll\": [\"f\", \"g\", \"h\"],
        \"b.dll\": [\"a\", \"b\", \"c\"]}")
Dict{String,Any} with 2 entries:
  "b.dll" =&gt; Any["a", "b", "c"]
  "a.dll" =&gt; Any["f", "g", "h"]

julia&gt; s2 = JSON.parse("{\"c.dll\": [\"x\", \"y\", \"z\"]}")
Dict{String,Any} with 1 entry:
  "c.dll" =&gt; Any["x", "y", "z"]

julia&gt; ex_dict = ExtractDict(Dict(
       	Symbol("a.dll") =&gt; ExtractArray(ExtractString()),
       	Symbol("b.dll") =&gt; ExtractArray(ExtractString()),
       	Symbol("c.dll") =&gt; ExtractArray(ExtractString()),
       ))
Dict
  ├── a.dll: Array of
  │            └── String
  ├── b.dll: Array of
  │            └── String
  └── c.dll: Array of
               └── String

julia&gt; ex_key_as_field = ExtractKeyAsField(
       	ExtractString(), ExtractArray(ExtractString()
       ))
KeyAsField
  ├── String
  └── Array of
        └── String

julia&gt; ex_dict(s1)
ProductNode with 1 obs
  ├── a.dll: BagNode with 1 obs
  │            └── ArrayNode(2053×3 NGramMatrix with Int64 elements) with 3 obs
  ├── b.dll: BagNode with 1 obs
  │            └── ArrayNode(2053×3 NGramMatrix with Int64 elements) with 3 obs
  └── c.dll: BagNode with 1 obs
               └── ArrayNode(2053×0 NGramMatrix with Int64 elements) with 0 obs

julia&gt; ex_key_as_field(s1)
BagNode with 1 obs
  └── ProductNode with 2 obs
        ├── item: BagNode with 2 obs
        │           ⋮
        └─── key: ArrayNode(2053×2 NGramMatrix with Int64 elements) with 2 obs

julia&gt; ex_dict(s2)
ProductNode with 1 obs
  ├── a.dll: BagNode with 1 obs
  │            └── ArrayNode(2053×0 NGramMatrix with Int64 elements) with 0 obs
  ├── b.dll: BagNode with 1 obs
  │            └── ArrayNode(2053×0 NGramMatrix with Int64 elements) with 0 obs
  └── c.dll: BagNode with 1 obs
               └── ArrayNode(2053×3 NGramMatrix with Int64 elements) with 3 obs

julia&gt; ex_key_as_field(s2)
BagNode with 1 obs
  └── ProductNode with 1 obs
        ├── item: BagNode with 1 obs
        │           ⋮
        └─── key: ArrayNode(2053×1 NGramMatrix with Int64 elements) with 1 obs</code></pre><p>As we can see <code>ExtractKeyAsField</code> extracts data to more sensible structures in this case.</p><h2 id="Modifying-extractor"><a class="docs-heading-anchor" href="#Modifying-extractor">Modifying extractor</a><a id="Modifying-extractor-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-extractor" title="Permalink"></a></h2><h3 id="Passing-different-scalar_extractors"><a class="docs-heading-anchor" href="#Passing-different-scalar_extractors">Passing different scalar_extractors</a><a id="Passing-different-scalar_extractors-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-different-scalar_extractors" title="Permalink"></a></h3><p>Let's demonstrate how can we set extraction of all strings to be <code>MultiRepresentation</code> of <code>String</code> and <code>Categorical</code>, where <code>Categorical</code> will have 20 most frequent values. In general, there are 2 approaches:</p><ul><li>prepending your own extractors to <code>default_scalar_extractor()</code></li><li>providing your own function independent on <code>default_scalar_extractor()</code></li></ul><p>The first case may look as follows:</p><pre><code class="language-julia"># we import necessary functions
using JsonGrinder: is_intable, is_floatable, unify_types, extractscalar
# define a helper function
top_n_keys(e::Entry, n::Int) = map(x-&gt;x[1], sort(e.counts |&gt; collect, by=x-&gt;x[2], rev=true)[begin:min(n, end)])
# we call the default extractor inside our
function string_multi_representation_scalar_extractor()
	vcat([
	(e -&gt; unify_types(sch[:paper_id]) &lt;: String,
		e -&gt; MultipleRepresentation((
			ExtractCategorical(top_n_keys(e, 20)),
			extractscalar(unify_types(e), e)
		))
	], JsonGrinder.default_scalar_extractor()))
end
# call the suggestextractor with out extractors
suggestextractor(sch, (; scalar_extractors = string_multi_representation_scalar_extractor()))</code></pre><p>The second case may look as follows: Let's take contents <code>default_scalar_extractor()</code> function and modify it</p><pre><code class="language-julia"># we import necessary functions
using JsonGrinder: is_intable, is_floatable, unify_types, extractscalar
# define a helper function
top_n_keys(e::Entry, n::Int) = map(x-&gt;x[1], sort(e.counts |&gt; collect, by=x-&gt;x[2], rev=true)[begin:min(n, end)])
function string_multi_representation_scalar_extractor()
	[
	(e -&gt; length(keys(e)) &lt;= 100 &amp;&amp; (is_intable(e) || is_floatable(e)),
		e -&gt; ExtractCategorical(keys(e))),
	(e -&gt; is_intable(e),
		e -&gt; extractscalar(Int32, e)),
	(e -&gt; is_floatable(e),
	 	e -&gt; extractscalar(FloatType, e)),
	# it's important that condition here would be lower than maxkeys
	(e -&gt; (keys_len = length(keys(e)); keys_len / e.updated &lt; 0.1 &amp;&amp; keys_len &lt; 10000 &amp;&amp; !(is_intable(e) || is_floatable(e))),
		e -&gt; ExtractCategorical(keys(e))),
	(e -&gt; true,
		e -&gt; MultipleRepresentation((
			ExtractCategorical(e, 20),
			extractscalar(unify_types(e), e)
			)
		)),]
end
# call the suggestextractor with out extractors
suggestextractor(sch, (; scalar_extractors = string_multi_representation_scalar_extractor()))</code></pre><p>Note that in the first case, the condition for new extractor is evaluated first, but in the latter case, it's the latest condition, so it's used only when the previous ones are not met.</p><h3 id="Manual-modifications-of-extractor"><a class="docs-heading-anchor" href="#Manual-modifications-of-extractor">Manual modifications of extractor</a><a id="Manual-modifications-of-extractor-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-modifications-of-extractor" title="Permalink"></a></h3><p>Because the extractor can be quite big, by default the <code>Base.show</code> shows only structure to depth of 3 and 20 children for each element.</p><p>The full extractor can by seen by <code>HierarchicalUtils.printtree(extractor)</code>. Usually edge-cases and complex cases are seen only on large schemas and extractors, which don't suit the documentation format. Thus the examination of schema and extractor, and manual modifications are in dedicated example <a href="https://github.com/CTUAvastLab/JsonGrinder.jl/blob/master/examples/schema_examination.jl">examples/schema_examination.jl</a> which creates schema and extractor based on data in <a href="https://github.com/CTUAvastLab/JsonGrinder.jl/blob/master/examples/documents">examples/documents</a>. We advice to check it out and try to run it by yourself.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../schema/">« Schema</a><a class="docs-footer-nextpage" href="../exfunctions/">Extractors overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 24 February 2021 21:20">Wednesday 24 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>